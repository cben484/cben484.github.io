[{"content":"上传测试 要写一点文字\n再放一点照片\n​​\n修改上传测试\n删除了之后再上传测试\n‍\n","date":"2025-02-23T18:09:40+08:00","permalink":"https://cben484.github.io/post/upload-test-1t5c3h.html","title":"上传测试"},{"content":"","date":"2025-02-23T14:44:20+08:00","permalink":"https://cben484.github.io/p/newnewnew/","title":"Newnewnew"},{"content":"动态部署 ","date":"2025-02-23T13:26:07+08:00","permalink":"https://cben484.github.io/p/mytest-test/","title":"Mytest Test"},{"content":"C++基础 什么是C++ how about the C++（https://www.tiobe.com/tiobe-index/）\nC++是C语言的拓展：\n继承了C语言的特性，关注性能\n与底层硬件紧密结合\n示例：存储整形数据是用大端法（高位在前）还是小端法（低位在前），是由硬件决定的，C++标准不做规定；JAVA对此有规定，对存储格式的统一化有代价，但是程序的移植很方便。这是易用性和性能上的取舍。\n​​\n​​\n对象声明周期的精确控制\n示例：C#中对象的销毁是自动的，有相应的线程和机制进行处理；C++中，对象的构造、使用、销毁都是程序员控制。这是易用性和性能上的取舍。\nZero-Overhead (开销的意思，ptx中见过，但是我此时忘了)Abstraction\n不需要为没有使用的语言特性付出成本\n示例：C++中的虚函数，没使用这个特性就没有相应的运行成本；C#中所有的对象基本都是Object的派生，类里定义的函数都是虚函数，即使不使用该特性，也需要付出成本\n示例：C++在堆上开辟内存（使用指针，间接引用）以及在栈上开辟内存（直接使用）；C#很多类不支持在栈上直接构造\n​​\n这个示例中，call operator new就会分配堆内存，好像不太对，operator new好像只是对应于new的汇编，而不是operator new就分配堆内存。我感觉作者的意思只是单纯的想告诉你分配到堆和分配到栈是不一样的\n使用一些语言特性不等于付出运行成本。\n示例：使用consteval关键字。代码复杂，但结果固定，在编译时直接完成计算（减少了运行时的负担，付出了编译成本）。\n​​\n这里的汇编mov eax,3表示在编译时就算出了结果，可以减少运行时的负担，但是相应的也会增加编译的成本\n引入大量特性，便于工程实践（需要单独开一个章节来了解一下）\n完成时间: 2025-02-22 三种编程范式：面向过程、面向对象、泛型\n函数重载、异常处理、引用\nC++是一系列不断衍化的标准集合：\nC++98/03, C++1, C++14, C++17, C++20, C++23?\n语言本身一直在改进（同样的需要单独开一个章节来了解）\nMemory Model\nLambda Expression\n标准库的改进（同样的需要单独开一个章节来了解）\ntype_traits / ranges\nauto_ptr\nC++标准的工业实现：\nMSVC / GCC / Clang \u0026hellip;\n每个编译器可能并不完全遵循标准\n示例： clang 10.0.1和clang 11.0.1 对同一段程序的编译结果不同。clang10.0.1没有遵循新版本C++标准对consteval关键字的规定。\n​​\n确实是，他这个汇编里面没有能够直接看到计算结果（4）\n不同的实现存在差异\n示例：C++标准没有明确规定的细节，gcc 10.2和clang 11.0.1的实现不同。二者对模版的别名的处理不同。\n​​\n总结：\n对C++的讨论不能脱离语境：标准版本、编译工具、开发平台、硬件环境等 C++更多应用于强调性能的环境（C++强调性能，意味着它能够让开发者在需要的时候直接与硬件交互、管理内存并优化计算，特别是在性能要求极高的应用场景中，C++能够提供其他高级语言无法匹敌的高效运行速度。 感觉对应的是前面讲的堆栈） 编程时应该遵循标准。例如，多线程的实现可以使用Windows或Linux的线程库，但更建议使用C++标准库 C++开发环境与相关工具 开发环境：\nVisual C++，GCC（G++），Clang（Clang++）\u0026hellip;\n集成开发环境：Visual Studio，CodeLite，Code::blocks，Eclipse\n工具：\nusr/bin/time:Linux下，查看程序运行使用的时间的工具\n示例：看sleep 1 这个指令使用的时间\n1 /usr/bin/time sleep 1 valgrind：Linux下，检查程序内存泄漏情况的工具\ncpp reference：C++百科全书（https://en.cppreference.com/w/）\nCompiler explorer：在线编译（到汇编）和运行C++程序，可以选择不同编译器（https://godbolt.org/）\nC++ insights：对代码进行等价的解释（https://cppinsights.io/）\nC++的编译/链接模型 简单的加工模型无法处理大型程序：这样的方式加工耗时长，同时每做少量修改都需要全部重新加工。\n​​\n分块处理：\n编译更耗资源，但一次处理输入较少 链接输入较多，但链接本身的处理速度较快 便于程序修改升级 ​​\n分块处理的衍生：\n定义/声明\n头文件/源文件\n翻译文件=源文件+相关头文件（直接或间接）-应忽略的预处理语句。间接引用头文件被称为头文件的展开。\n一处定义原则\n程序级：一般函数 翻译单元级：内联函数、类、模版 编译/链接过程：\n预处理：头文件（.h）+源文件（.cpp）→翻译单元（.i）\n防止头文件重复展开：\n#ifdef解决方案：定义宏 #pragma once 解决方案：对展开进行计数，只会展开一次 编译：翻译单元（.i）→汇编代码（.s）\n编译优化：将复杂程序进行等价的简化。编译优化本身会对代码进行修改，因此无法设置断点，不利于调试。\n​​\n增量汇编 v.s. 全部汇编\n汇编：汇编代码（.i）→目标文件（机器码）（.o）\n链接：多个目标文件（.o）→可执行程序，Linux下可以用nm命令查看所有链接\n合并多个目标文件，关联声明与定义 链接（Linkage）种类：内部链接、外部链接、无连接 常见错误：找不到定义（undefined reference） ​​\n","date":"2025-02-22T20:10:23+08:00","permalink":"https://cben484.github.io/post/c-basics-qofmn.html","title":"C++基础"},{"content":"初探C++ 从Hello world谈起 1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 函数：一段能被反复调用的代码，可以接收输入，进行处理并（或）产生输出\n返回类型：表示了函数返回结果的类型，可以为void\n函数名：用于函数调用\n形参列表：表示函数接收的参数类型，可以为\n空\n1 void fun(); void\n1 void fun(void); 无形参\n当我们需要保留相应的接口，但实际不需要使用这个形参的时候，可以这么写。\n1 void fun(const char* pInfo,int);//第二个形参没有名字。 函数体：具体的执行逻辑\nmain函数：特殊的函数，作为整个程序的入口\n返回类型为int，这是现代C++标准规定的。\n通常使用0来表示正常返回。 main的返回值在执行过程中不显示，但是会被操作系统获取，可以通过一些办法（例如Linux下的echo命令）来获取。 一般函数的返回必须和返回类型匹配，只有main函数例外。如果main函数没有返回值，系统默认返回0. C++规定了，main函数可以有两种形参列表：\n为空\n1 int main(){} 两个形参，第一个参数是一个int形参，第二个形参是C风格字符串数组。可以任意命名，也可以是无形参，约定俗成为argc和argv。\n1 int main(int argc,char* argv[]) 或\n1 int main(int argc,char** argv) 第一个参数argc是一个int型参数，表示有多少个参数将传递给主函数main()。实际传递的参数都以C风格字符串（即字符串数组）的形式保存在第二个形参argv中。通常argv[0]存储的是当前程序的路径和名称，从argv[1]到argv[argc-1]存储的是其他的命令行参数字符串。\n1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; int main(int argc, char *argv[]) { for (int i=0; i\u0026lt;argc; i++) std::cout \u0026lt;\u0026lt; \u0026#34;argv[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; argv[i] \u0026lt;\u0026lt; std::endl; return 0; } 1 2 3 4 5 ./main Shanghai Jiaotong EE argv[0] = main argv[1] = Shanghai argv[2] = Jiaotong argv[3] = EE （内建）类型：为一段存储空间赋予实际的意义，规定了数据存储的格式。\n​​\n语句：表明了需要执行的操作\n表达式+分号的语句 语句块，用{}框起 if/while等语句 注释：会被编译器忽略的内容\n用于编写说明或去除不适用的语句 两种注释形式：/**/(vscode中的快捷键：alt+shift+a)与// ‍\n‍\n系统I/O iostream：标准库所提供的IO接口，用于与用户交互。以c开头，意为character\n输入流：cin，从键盘输入\n输出流：cout/cerr/clog，输出到屏幕\n输出流的区别：\n输出目标。例如我们可以重定向输出\n1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;output from cout\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;output from cerr\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;output from clog\u0026#34;; } 1 2 3 ./output \u0026gt; txt1 2\u0026gt;txt2 cat ./txt1 cat ./txt2 cerr 和 clog的区别为是否立即刷新缓冲区。\nclog会等缓冲区满了再刷新，cerr会立即刷新缓冲区\n输出字符是比较费时的，无论是输出到屏幕还是输出到文件。所以C++会首先建立缓冲区，把输出的内容输出到缓冲区。当刷新缓冲区时，会一次性输出到屏幕或文件。\n假设程序存在bug，程序崩溃时缓冲区的内容可能还没输出。因此cerr有立即刷新缓冲区的机制，但是这会影响性能。\n缓冲区刷新：\nstd::flush :主动刷新缓冲区 std::end :主动刷新缓冲区，并换行。 系统I/O的头文件\n1 #include\u0026lt;iostream\u0026gt; 关于头文件\n引用头文件有两种符号\n使用\u0026lt;\u0026gt;时，系统从系统的环境变量寻找头文件 使用\u0026quot;\u0026ldquo;时，系统从当前目录开始寻找头文件 后缀\n我们自己写的头文件往往有后缀，如 .h C++ 标准库的头文件没有后缀 ‍\n命名空间（namespace）：用于防止名称冲突\n1 2 3 4 namespace NameSpace1 { int x; void fun() {}; } 访问名字空间中元素的3种方式：\n域解析符::\n1 NameSpace1::fun(); using语句\n1 2 using namespace NameSpace1; fun(); 在头文件中使用using语句非常危险。因为这会把这个命名空间暴露给所有引用这个头文件的源文件。\n命名空间别名\n1 2 namespace ns1 = NameSpace1; ns1::fun(); std: C++标准库的命名空间\n命名空间与名称改编（name mangling）\n在链接时，对不同命名空间中的同名对象，编译器会对名称进行修改。不同编译器的修改规则不同，但不会改变main函数的名称。\n在用nm语句查看链接时，看到的是经过修改的名字。可以用c++filt语句把名字改回来。(了解一下，nm语句查看的是链接修改之后的名字， filt语句查看的是修改之前的名字)\n在C++中可以使用C的系统IO，需要引入头文件 stdio.h 或 cstdio。C / C++ 系统 IO 比较：\nprintf和scanf：使用占位符，直观但容易出错 cout：不容易出错，但书写冗长 C++20格式化库：新的解决方案 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; int main(){ int x = 10; std::cout \u0026lt;\u0026lt; \u0026#34;I have \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; pens.\\n\u0026#34;; printf(\u0026#34;I have %d pens.\\n\u0026#34;, x); } ‍\n猜数字与控制流 控制流：逻辑上改变语句执行的顺序\nif语句：用于分支执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; int main() { const int x = 42; std::cout \u0026lt;\u0026lt; \u0026#34;Please input a number: \\n\u0026#34;; int y = 0; std::cin \u0026gt;\u0026gt; y; if (y == x) { std::cout \u0026lt;\u0026lt; \u0026#34;You are right!\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;You are wrong!\\n\u0026#34;; } } ‍\n​​\n条件部分：用于判断是否执行 语句部分：要执行的操作 ==与=操作\n=操作：用于赋值，将数值保存在变量所对应的内存中\n赋值表达式也有返回值，返回值就是所赋的值\n1 2 int x, y; x = y = 42; // 执行顺序 x = (y = 42); ==操作：用于判断两个值是否相等\n可以将常量放在==左边以防止误用\nwhile语句：用于循环执行\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; int main() { const int x = 42; int y = 0; while (x != y) { std::cout \u0026lt;\u0026lt; \u0026#34;Please input a number: \\n\u0026#34;; std::cin \u0026gt;\u0026gt; y; } } ‍\n条件部分：用于判断是否执行 语句部分：要执行的操作 结构体与自定义数据类型 C语言同样有结构体。C++相对于C语言的拓展，大多数都是从结构体开始衍生。整个面向对象编程的体系都是基于C语言的结构体衍生的。\n结构体（struct）：将相关的数据放置在一起\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Point { int x, y; void IncX() { x = x+1; } }; void fun(Point p) { p.x = p.x + 1; return p; } int main() { Point p; p.x = 3; p.y = 5; std::cout \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; p = fun(p); std::cout \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; p.IncX(); std::cout \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 可以通过点操作符( . )访问内部元素 可以作为函数的输入参数或返回类型 可以引入成员函数，更好地表示函数与数据的相关性 ","date":"2025-02-22T20:10:21+08:00","permalink":"https://cben484.github.io/post/preliminary-exploration-c-z17lbi0.html","title":"初探C++"},{"content":"常识总结 最优化问题（Optimization problem） 数学、工程学、计算机科学和经济学领域中，最优化问题，或称优化问题（Optimization problem）是指从所有可行解中找到最优良的解的问题。\n根据变量是连续的或离散的，可将最优化问题分为两类：\n具有离散变量的最优化问题称为离散优化，其中必须找到可数集合中的整数排列或图等对象。 具有连续变量的最优化问题称为连续优化，其中必须找到连续函数的最优值。它们可以包括约束问题和多模态问题 最优化问题和决定性问题（在可计算性理论与计算复杂性理论中，决定性问题，亦称判定问题，（英语：Decision problem）是一个在某些形式系统回答“是”或“否”的问题。）、功能性问题（在计算复杂性理论内，函数问题（英语：Function problem）或者功能性问题是一种计算问题，对任何一种输入都预期会有单一个输出，但是输出不像是决定性问题一样这么单纯。换句话说，输出不只是或否，比决策问题复杂得多。重要的范例像是旅行推销员问题，询问一张图是否有可以绕过每一点的不重复路径（输出为路径），以及整数分解，输出为输入的质因数。）不同，最优化问题是：从问题的多个解中，求出最佳解。像背包问题（考虑不同价格和重量的物品，以及可承载一定重量的背包，如何选择物品，使背包中的物品的总价最高）即属于最优化问题。\n内点法（Interior point method） 内点法（也称为障碍法或IPM）是用于解决线性和非线性凸优化问题的算法。IPM结合了先前已知算法的两个优点：\n从理论上将，它们的运行时间是多项式的——与单纯形法相反，后者在最坏情况下的运行时间是指数的（内点法具有多项式时间复杂度，即随着问题的规模增加，算法的运行时间按多项式的速度增长。这是一个很重要的优点，因为它意味着在理论上，算法的运行时间不会增长得过快，适合解决大规模问题。 虽然单纯形法在最坏情况下的时间复杂度是指数级的（这意味着在某些特定的情况下，单纯形法的运行时间会非常长，可能会增长到非常大的数值。因此，单纯形法在理论上不如内点法稳定），但是在实际应用中，单纯形法往往能非常高效率地解决大多数问题，其速度与内点法差不多。也就是说，尽管单纯形法在最坏情况下表现得不如内点法，但在实际使用中，单纯形法也能很快地找到解。）。 实际上，他们的运行速度和单纯形法一样快（但是在实际应用中，单纯形法往往能非常高效率地解决大多数问题，其速度与内点法差不多。也就是说，尽管单纯形法在最坏情况下表现得不如内点法，但在实际使用中，单纯形法也能很快地找到解。），而椭圆体法则相反，虽然它在理论上具有多项式运行时间，但在实践中却非常慢（虽然椭圆体法的理论时间复杂度是多项式的，但在实际应用中，它往往非常慢。尽管它在理论上具备多项式时间复杂度，但实际上在很多情况下，椭圆体法的效率较低，运行时间长。）。 与​遍历可行域边界​的​单纯形法​和​从外部限制可行域​的​椭圆体法​相比，IPM 通过​遍历可行域内部​*来（可行域是指所有满足约束条件的解的集合。可行域是一个包含所有合法解的区域，这些解不仅符合问题的目标函数，而且还满足问题中给定的约束条件 单纯形法：通过遍历可行域的边界来寻找最优解。单纯形法总是从一个可行解开始，沿着可行域的边界走，逐步改进目标函数的值，直到找到最优解 椭圆体法：通过外部逐渐逼近可行域的边界来找到最优解 内点法（IPM）：内点法通过在可行域的内部进行搜索，逐渐逼近最优解。因此，它与单纯性法和椭圆体法的不同之处在于它不沿着边界寻找解，而是探索可行域的内部。）*​达到最佳解决方案- 由此得名。(可行域是指所有满足约束条件的解的集合。可行域是一个包含所有合法解的区域，这些解不仅符合问题的目标函数，而且还满足问题中给定的约束条件 单纯形法：通过遍历可行域的边界来寻找最优解。单纯形法总是从一个可行解开始，沿着可行域的边界走，逐步改进目标函数的值，直到找到最优解 椭圆体法：通过外部逐渐逼近可行域的边界来找到最优解 内点法（IPM）：内点法通过在可行域的内部进行搜索，逐渐逼近最优解。因此，它与单纯性法和椭圆体法的不同之处在于它不沿着边界寻找解，而是探索可行域的内部。)\n‍\n","date":"2025-02-21T10:09:25+08:00","permalink":"https://cben484.github.io/post/summary-of-common-sense-8czg.html","title":"常识总结"},{"content":"TIPS SharedMem Capability The amount of the unified data cache reserved for shared memory is configurable on a per kernel basis.\nVolta(compute capability 7.0),the unified data cache has a size of 128KB, and the shared memory capacity can be set to 0,8,16,32,64 or 96KB.\nTuring(compute capability 7.5),the unified data cache has a size of 96KB, and the shared memory capacity can be set to either 32KB or 64KB.\nAmpere(compute capability 8.0 and 8.7),the unified data cache has a size of 192KB, and the shared memory capacity can be set to 0,8,16,32,64,100,132 or 164KB.\n(compute capability 8.6 and 8.9),the unified data cache has a size of 128KB,and the shared memory capacity can be set 0,8,16,32,64 or 100KB.\nHopper(compute capability 9.0),the unified data cache has a size of 256KB,and the shared memory capacity can be set 0,8,16,32,64,100,132,164,196 or 228KB.\n‍\nSharedMem Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays.These kernels require an explicit opt-in by using ​cudaFuncSetAttribute()​ to set the ​cudaFuncAttributeMaxDynamicSharedMemorySize​\n‍\nNote that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.(always smaller 1KB than partition at least for system)\n‍\nPTX Coorperative thread arrays (CTAs) implement CUDA thread blocks and clusters implement CUDA thread block clusteres.\nAll instruction keywords are reserved tokens in PTX.\nAll variables reside in some state space.\nAll whitespace characters are equivalent; whitespace is ignored except for its use in separating tokens in the language.\nComments in PTX are treated as whitespace.\nIn principle, all variables (aside from predicates) could be declared using only bit-size types, but typed variables enhance program readability and allow for better operand type checking.\nThe bit-size type is compatible with any fundamental type having the same size.\n","date":"2025-02-16T14:01:55+08:00","permalink":"https://cben484.github.io/post/tips-z1wp3rc.html","title":"TIPS"},{"content":"PTX（Parallel Thread Execution） 1 2 3 4 5 6 __device__ __forceinline__ int load_int_from_global(const int* a) { int r; asm volatile(\u0026#34;ld.global.cs.s32 %0, [%1];\u0026#34; : \u0026#34;=r\u0026#34;(r) : \u0026#34;l\u0026#34;(a)); return r; } DASP/src/dasp_f16.h中的例子，用了ptx指令\n‍\n这个代码总体的意思是，根据输入的参数a，a是一个指向全局内存数据的指针，\n通过调用ptx指令，将这个数据直接存入到寄存器中用了操作数约束\u0026quot;=r(r)\u0026ldquo;将r与寄存器相绑定，所以ptx将数据放入寄存器的时候，r就已经有值了\n此时再返回r，就完成了这个load from global的操作了\nld.global.cs.s32：ld.global表示从全局内存中加载数据，cs(cache streaming)表示缓存策略，优化一次性加载数据的性能。s32表示加载的数据类型是32位有符号数。\nasm是assembly（汇编）的缩写，用于在高层语言（C++或CUDA）中插入底层汇编代码，在CUDA中，用于嵌入PTX汇编指令。\nvolatile是一个修饰符，表示汇编指令可能被修改，防止编译器优化或重新排序\nasm和volatile组合表示，确保嵌入的汇编代码在任何优化情况下都被执行。\n‍\n这里的=r是约束修饰符，将r变量约束到寄存器上，绑定到寄存器上\n寄存器约束，=r(r)，r被分配到一个寄存器\nPTX指令会将全局内存中加载的值存储到这个寄存器\n有等号和没有等号是有区别的，=表示输出操作数，该变量的值将在汇编执行后被更新，没有=表示输入操作数，该变量的值在汇编指令中作为只读数据，不会被修改。\n1 例子：asm volatile(\u0026#34;ld.global.cs.u32 %0, [%1];\u0026#34; : \u0026#34;=r\u0026#34;(r) : \u0026#34;l\u0026#34;(a)); 内存约束，m，PTX指令将寄存器中的值存储到output指定的内存地址 1 例子：asm volatile(\u0026#34;st.global.u32 [%0], %1;\u0026#34; : : \u0026#34;m\u0026#34;(output), \u0026#34;r\u0026#34;(value)); 立即数约束，i，表示变量需要绑定到一个立即数（常量），PTX 指令将执行按位左移操作。 1 例子：asm volatile(\u0026#34;shl.b32 %0, %1, %2;\u0026#34; : \u0026#34;=r\u0026#34;(result) : \u0026#34;r\u0026#34;(value), \u0026#34;i\u0026#34;(shift)); ‍\n在以下两个例子中，出现了有单个冒号和双冒号的情况，多了解了一下：\n这个冒号实质上是用于分隔输出操作数和输入操作数的，前者为输出操作数，后者为输入操作数，在第二例子中，函数实现的功能是store操作，是void没有输出，所以没有输出操作数，自然就形成了两个冒号了。\n1 2 3 4 5 6 7 __device__ __forceinline__ half load_half_from_global(const half* a) { ushort r; asm volatile(\u0026#34;ld.global.cs.u16 %0, [%1];\u0026#34; : \u0026#34;=h\u0026#34;(r) : \u0026#34;l\u0026#34;(a)); half *r_half = reinterpret_cast\u0026lt;half *\u0026gt;(\u0026amp;r); return *r_half; } 1 2 3 4 5 __device__ __forceinline__ void store_half_to_global(const half* a, half v) { ushort *v_u = reinterpret_cast\u0026lt;ushort *\u0026gt;(\u0026amp;v); asm volatile(\u0026#34;st.global.cs.u16 [%0], %1;\u0026#34; :: \u0026#34;l\u0026#34;(a), \u0026#34;h\u0026#34;(*v_u)); } ‍\n1. PTX Introduction PTX​ defines a virtual machine and ISA for general purpose parallel thread execution. PTX programs are translated at install time to the target hardware instruction set. The PTX-to-GPU translator and driver enable NVIDIA GPUs to (ptx提供了一个虚拟机和指令集架构，PTX到GPU的编译器和驱动使得英伟达GPU能够作为可编程的并行计算机使用)​be used as programmable parallel computers.(ptx提供了一个虚拟机和指令集架构，PTX到GPU的编译器和驱动使得英伟达GPU能够作为可编程的并行计算机使用)\n‍\n2. PTX Programming Model 2.1 A Highly Multithreaded Coprocessor The GPU is a compute device capable of executing a very large number of threads in parallel. It operates as a coprocessor to the main CPU, or host: In other words, data-parallel, compute-intensive portions of applications running on the host are off-loaded onto the device.\nMore precisely, a portion of an application that is executed many times, but independently on different data, can be isolated into a kernel function that is executed on the GPU as many different threads. To that effect, such a function is compiled to the PTX instruction set and the resulting kernel is translated at install time to the target GPU instruction set.\n2.2 Thread Hierarchy(ptx的线程层次结构和cuda的不一样，cuda里面叫做block，这里叫做CTA（真是服了）) The batch of threads that executes a kernel is organized as a grid. A grid consists of either cooperative thread arrays or clusters of cooperative thread arrays as described in this section and illustrated in Figure 1 and Figure 2. *Cooperative thread arrays (CTAs)(所以可以直接将CTA视为block，clusters视为block clusters是吧)*​ implement CUDA thread blocks and clusters implement CUDA thread block clusters.(所以可以直接将CTA视为block，clusters视为block clusters是吧)\n2.2.1 Cooperative Thread Arrays The Parallel Thread Execution (PTX) programming model is explicitly parallel: a PTX program specifies the execution of a given thread of a parallel thread array. A cooperative thread array, or CTA, is an array of threads that execute a kernel concurrently or in parallel.\nThreads within a CTA can communicate with each other. To coordinate the communication of the threads within the CTA, one can specify synchronization points where threads wait until all threads in the CTA have arrived.(指出，为了协调CTA内部线程的通信，可以指定同步点。 指明了同步的作用之一是为了CTA内部线程的通信。)\nEach thread has a unique thread identifier within the CTA. Programs use a data parallel decomposition to partition inputs, work, and results across the threads of the CTA. Each CTA thread uses its thread identifier to determine its assigned role, assign specific input and output positions, compute addresses, and select work to perform.(程序员通过线程标识符，即tid，来控制CTA线程的行为 ) The thread identifier is a three-element vector tid​, (with elements tid.x​, tid.y​, and tid.z​) that specifies the thread’s position within a 1D, 2D, or 3D CTA. Each thread identifier component ranges from zero up to the number of thread ids in that CTA dimension.\nEach CTA has a 1D, 2D, or 3D shape specified by a three-element vector ​ntid​ (with elements ​ntid.x​, ​ntid.y​, and ​ntid.z​). (ntid指定了CTA的shape )The vector ntid​ specifies the number of threads in each CTA dimension.\nThreads within a CTA execute in SIMT (single-instruction, multiple-thread) fashion in groups called ​warps​.(这句话明确说了，warp里面的线程的执行方式就是SIMT) A warp is a maximal subset of threads from a single CTA, such that the threads execute the same instructions at the same time. Threads within a warp are sequentially numbered. The warp size is a machine-dependent constant. Typically, a warp has 32 threads. (他这样说的，感觉warp的大小有可能随着未来的发展而变化)Some applications may be able to maximize performance with knowledge of the warp size, so PTX includes a run-time immediate constant, WARP_SZ​, which may be used in any instruction where an immediate operand is allowed.\n2.2.2 Cluster of Cooperative Thread Arrays(有block就有block cluster，有CTA就有CTA cluster) Cluster is a group of CTAs that run concurrently or in parallel and can synchronize and communicate with each other via shared memory. The executing CTA has to make sure that the shared memory of the peer CTA exists before communicating with it via shared memory and the peer CTA hasn’t exited before completing the shared memory operation.\nThreads within the different CTAs in a cluster can synchronize and communicate with each other via shared memory. Cluster-wide barriers can be used to synchronize all the threads within the cluster. Each CTA in a cluster has a unique CTA identifier within its cluster (​cluster_ctaid​ ) . Each cluster of CTAs has 1D, 2D or 3D shape specified by the parameter cluster_nctaid. Each CTA in the cluster also has a unique CTA identifier (​cluster_ctarank​ ) across all dimensions. The total number of CTAs across all the dimensions in the cluster is specified by cluster_nctarank. Threads may read and use these values through predefined, read-only special registers ​​%cluster_ctaid​​, ​​%cluster_nctaid​​, ​​%cluster_ctarank​​, ​​%cluster_nctarank​​.\nCluster level is applicable only on target architecture sm_90​ or higher. Specifying cluster level during launch time is optional. If the user specifies the cluster dimensions at launch time then it will be treated as explicit cluster launch, otherwise it will be treated as implicit cluster launch with default dimension 1x1x1. PTX provides read-only special register %is_explicit_cluster​ to differentiate between explicit and implicit cluster launch.\n2.2.3 Grid of Clusters(有block就有grid，他这里写的是grid of clusters) There is a maximum number of threads that a CTA can contain and a maximum number of CTAs that a cluster can contain. However, clusters with CTAs that execute the same kernel can be batched together into a grid of clusters, so that the total number of threads that can be launched in a single kernel invocation is very large. (处理相同内核的CTA可以批处理到一起，形成一个集群网络，从而使得单次内核调用中可启动的总线程数非常大)​This comes at the expense of reduced thread communication and synchronization, because threads in different clusters cannot communicate and synchronize with each other.(只有集群内部的线程才是可以通信和同步的，集群之间无法做到，所以集群网络形成的条件是以减少线程间通信和同步为代价的)\nEach cluster has a unique cluster identifier (clusterid) within a grid of clusters. Each grid of clusters has a 1D, 2D , or 3D shape specified by the parameter nclusterid. Each grid also has a unique temporal grid identifier (gridid). Threads may read and use these values through predefined, read-only special registers ​​%tid​​, ​​%ntid​​, ​​%clusterid​​, ​​%nclusterid​​, and ​​%gridid​​.\nEach CTA has a unique identifier (ctaid) within a grid. Each grid of CTAs has 1D, 2D, or 3D shape specified by the parameter nctaid. Thread may use and read these values through predefined, read-only special registers ​​%ctaid​​ and ​​%nctaid​​.\nEach kernel is executed as a batch of threads organized as a grid of clusters consisting of CTAs where cluster is optional level and is applicable only for target architectures sm_90​ and higher. Figure 1 shows a grid consisting of CTAs and Figure 2 shows a grid consisting of clusters.\nGrids may be launched with dependencies between one another - a grid may be a dependent grid and/or a prerequisite grid. To understand how grid dependencies may be defined, refer to the section on ​CUDA Graphs​ in the ​*Cuda Programming Guide(这样一看，似乎可以起不止一个grid)*​.(这样一看，似乎可以起不止一个grid)\n2.3 Memory Hierarchy(累了，明天再看这个) PTX threads may access data from multiple state spaces during their execution as illustrated by Figure 3 where cluster level is introduced from target architecture sm_90​ onwards. Each thread has a private local memory. Each thread block (CTA) has a shared memory visible to all threads of the block and to all active blocks in the cluster and with the same lifetime as the block. Finally, all threads have access to the same global memory.\nThere are additional state spaces accessible by all threads: the constant, param, texture, and surface state spaces. Constant and texture memory are read-only; surface memory is readable and writable. The global, constant, param, texture, and surface state spaces are optimized for different memory usages. For example, texture memory offers different addressing modes as well as data filtering for specific data formats. Note that texture and surface memory is cached, and within the same kernel call, the cache is not kept coherent with respect to global memory writes and surface memory writes, so any texture fetch or surface read to an address that has been written to via a global or a surface write in the same kernel call returns undefined data. In other words, a thread can safely read some texture or surface memory location only if this memory location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread from the same kernel call.\nThe global, constant, and texture state spaces are persistent across kernel launches by the same application.\nBoth the host and the device maintain their own local memory, referred to as host memory and device memory, respectively. The device memory may be mapped and read or written by the host, or, for more efficient transfer, copied from the host memory through optimized API calls that utilize the device’s high-performance Direct Memory Access (DMA) engine.\n4. PTX Syntax PTX programs are a collection of text source modules (files). PTX source modules have an assembly-language style(汇编风格 ) syntax with instruction operation codes and operands. Pseudo-operations specify symbol and addressing management. The ptxas optimizing backend compiler(ptxas后端优化编译器，整体是一个名词，这个编译器优化并汇编了PTX源模块来生成对应的二进制对象文件（我估计就是sass）) optimizes and assembles PTX source modules to produce corresponding binary object files.\n4.1 Source Format Source modules are ASCII text. Lines are separated by the newline character (换行符 )(\\n​).\nAll whitespace characters are equivalent; whitespace is ignored except for its use in separating tokens in the language.(所有空白符是等效的，空白符只在分隔语言中的标记时起作用。)\nThe C preprocessor cpp(这里的cpp应该指的是C preprocessor，pp是来自于preprocessor) may be used to process PTX source modules. Lines beginning with #​ are preprocessor directives(directives好像是指令的意思，在ptx里面似乎特指那些预处理指令，在4.3里面有提到directive or instruction，说明这俩是有区分的，在4.3在细说区分). The following are common preprocessor directives:\n​#include​, #define​, #if​, #ifdef​, #else​, #endif​, #line​, #file​\nC: A Reference Manual by Harbison and Steele provides a good description of the C preprocessor.\nPTX is case sensitive and uses lowercase for keywords.(ptx大小写敏感，关键字都是小写)\nEach PTX module must begin with a ​.version​ directive specifying the PTX language version, followed by a ​.target​ directive specifying the target architecture assumed.(每个ptx模块都是由.version开头，指定ptx版本，后面跟一个.target指明目标架构) See PTX Module Directives for a more information on these directives.\n4.2 Comments(ptx的注释规则，和C/CPP基本上是一样的，不一样的点勾画出来了) Comments in PTX follow C/C++ syntax, using non-nested /*​ and */​ for comments that may span multiple lines, and using //​ to begin a comment that extends up to the next newline character, which terminates the current line. Comments cannot occur within character constants, string literals, or within other comments.\nComments in PTX are treated as whitespace.\n4.3 Statements(语句) A PTX statement is either a directive or an instruction.(这里对directive和instruction做了一个区分 1. Directive（指令） 定义：Directive 是 PTX 代码中的预处理指令，它告诉编译器如何处理代码，或者定义一些编译时的设置。Directive 本身不执行任何计算，它们通常用于设定数据、寄存器等的属性，或者控制代码生成的过程。 作用：它们通常用于定义变量、注册信息、内存空间等设置。例如，定义寄存器、全局内存、共享内存等。 常见的 PTX directive 示例： .reg：用于定义寄存器。 .global：用于定义全局内存。 .shared：用于定义共享内存。 .const：用于定义常量内存。 示例： .reg .b32 r1, r2; // 定义32位的寄存器r1和r2 .global .f32 array[N]; // 定义一个名为array的全局浮点数组 2. Instruction（指令） 定义：Instruction 是 PTX 中的计算或操作指令，它执行具体的操作或计算任务。指令是程序实际执行的代码，涉及算术运算、内存访问、控制流等。 作用：它们执行各种类型的操作，如加载/存储、算术计算、控制流指令（跳转、条件判断）等。 常见的 PTX instruction 示例： mov：移动数据。 add：加法运算。 ld.global：全局内存加载。 shl：按位左移。 示例： mov.b32 r1, %tid.x; // 将线程ID的x部分存入寄存器r1 add.f32 r2, r2, 0.5; // 将寄存器r2的值加上0.5 shl.b32 r1, r1, 2; // 将寄存器r1的值左移2位 主要区别： Directive 是编译时的指令，主要用于设置或声明变量、寄存器、内存等，它们并不执行实际的计算。 Instruction 是执行时的指令，它们执行具体的计算任务或内存操作，是程序执行的核心部分。 总结来说，directive 主要负责代码的配置和声明，而 instruction 则是实际的操作指令，控制程序的计算过程。) Statements begin with an optional label(以可选的标签开头) and end with a semicolon.(以分号结尾 )\nExamples\n1 2 3 4 5 6 7 .reg .b32 r1, r2; .global .f32 array[N]; start: mov.b32 r1, %tid.x; shl.b32 r1, r1, 2; // shift thread id by 2 bits ld.global.b32 r2, array[r1]; // thread[tid] gets array[tid] add.f32 r2, r2, 0.5; // add 1/2 4.3.1 Directive Statements Directive keywords begin with a dot, so no conflict is possible with user-defined identifiers. The directives in PTX are listed in Table 1 and described in State Spaces, Types, and Variables and Directives.\n​​\n4.3.2 Instruction Statements(操作码+操作数（操作数以逗号分隔，以分号结束）) Instructions are formed from an instruction opcode followed by a comma-separated(以逗号分隔) list of zero or more operands, and terminated with a semicolon(以分号结尾). Operands may be register variables, constant expressions, address expressions, or label names. Instructions have an optional guard predicate which controls conditional execution. The guard predicate follows the optional label and precedes the opcode, and is written as @p​, where p​ is a predicate register. The guard predicate may be optionally negated, written as @!p​.\nThe destination operand is first, followed by source operands.\nInstruction keywords are listed in Table 2. All instruction keywords are reserved tokens in PTX(太长了，我没截下来，ctrl点Table2就可以看到了).\n4.4 Identifiers(标识符) User-defined identifiers follow extended C++ rules: they either start with a letter followed by zero or more letters, digits, underscore, or dollar characters; or they start with an underscore, dollar, or percentage character followed by one or more letters, digits, underscore, or dollar characters:\n1 2 followsym: [a-zA-Z0-9_$] identifier: [a-zA-Z]{followsym}* | {[_$%]{followsym}+ PTX does not specify a maximum length for identifiers and suggests that all implementations support a minimum length of at least 1024 characters.\nMany high-level languages such as C and C++ follow similar rules for identifier names, except that the percentage sign is not allowed. PTX allows the percentage sign as the first character of an identifier. The percentage sign can be used to avoid name conflicts, e.g., between user-defined variable names and compiler-generated names.\nPTX predefines one constant and a small number of special registers that begin with the percentage sign(PTX以百分号开头预定义了一些特殊寄存器), listed in Table 3.\n​​\n4.5 Constants PTX supports integer and floating-point constants and constant expressions. These constants may be used in data initialization and as operands to instructions. Type checking rules remain the same for integer, floating-point, and bit-size types. For predicate-type data and instructions, integer constants are allowed and are interpreted as in C, i.e., zero values are False​ and non-zero values are True​.\n4.5.1 Integer Constants Integer constants are 64-bits in size and are either signed or unsigned, i.e., every integer constant has type .s64​ or .u64​. The signed/unsigned nature of an integer constant is needed to correctly evaluate constant expressions containing operations such as division and ordered comparisons, where the behavior of the operation depends on the operand types. When used in an instruction or data initialization, each integer constant is converted to the appropriate size based on the data or instruction type at its use.\nInteger literals may be written in decimal, hexadecimal, octal, or binary(十进制、十六进制、八进制或二进制) notation. The syntax follows that of C. Integer literals may be followed immediately by the letter U​ to indicate that the literal is unsigned.\n1 2 3 4 hexadecimal literal: 0[xX]{hexdigit}+U? octal literal: 0{octal digit}+U? binary literal: 0[bB]{bit}+U? decimal literal {nonzero-digit}{digit}*U? Integer literals are non-negative and have a type determined by their magnitude and optional type suffix as follows: literals are signed (.s64​) unless the value cannot be fully represented in .s64​ or the unsigned suffix is specified, in which case the literal is unsigned (.u64​).\nThe predefined integer constant WARP_SZ​ specifies the number of threads per warp for the target platform; to date, all target architectures have a WARP_SZ​ value of 32.\n4.5.2 Floating-Point Constants Floating-point constants are represented as 64-bit double-precision values, and all floating-point constant expressions are evaluated using 64-bit double precision arithmetic. The only exception is the 32-bit hex notation for expressing an exact single-precision floating-point value; such values retain their exact 32-bit single-precision value and may not be used in constant expressions. Each 64-bit floating-point constant is converted to the appropriate floating-point size based on the data or instruction type at its use.\nFloating-point literals may be written with an optional decimal point and an optional signed exponent. Unlike C and C++, there is no suffix letter to specify size; literals are always represented in 64-bit double-precision format.\nPTX includes a second representation of floating-point constants for specifying the exact machine representation using a hexadecimal constant. To specify IEEE 754 double-precision floating point values, the constant begins with (双精度浮点数 是0d或者0D开头，后面跟16个16进制 单精度浮点数 是0f或者0F开头，后面跟8个16进制)​0d​ or ​0D​ followed by 16 hex digits. To specify IEEE 754 single-precision floating point values, the constant begins with ​0f​ or ​0F(双精度浮点数 是0d或者0D开头，后面跟16个16进制 单精度浮点数 是0f或者0F开头，后面跟8个8进制)​ followed by 8 hex digits.(双精度浮点数 是0d或者0D开头，后面跟16个16进制 单精度浮点数 是0f或者0F开头，后面跟8个8进制)\n1 2 0[fF]{hexdigit}{8} // single-precision floating point 0[dD]{hexdigit}{16} // double-precision floating point Example\n1 mov.f32 $f3, 0F3f800000; // 1.0 4.5.3 Predicate (谓词，有点陌生的词汇。 谓词（Predicate）是一个逻辑或条件判断的术语，通常表示一种“判断式”或“条件”，用于判断某个特定的条件是否成立。在编程语言中，谓词通常是一个表达式，其值为真或假（True 或 False）。 在 PTX 这样的汇编语言中，谓词常常用于控制程序的执行流程，例如在某些指令的执行上进行条件判断。 假设我们有一个简单的条件语句： if (x \u0026gt; 5) { // 执行某些操作 } 在这里，x \u0026gt; 5 就是一个谓词，它的值是一个布尔值（True 或 False）。如果 x 的值大于 5，谓词 x \u0026gt; 5 为 True，那么就会执行后面的操作；如果 x 小于或等于 5，谓词为 False，操作就不会执行。 在 PTX 中的应用： 在 PTX 汇编中，整数常量可以作为谓词使用。具体来说，0 被视为 False，非零整数（比如 1）被视为 True。例如： setp.eq.u32 p0, r1, 0; // p0 为 1 时，相当于 True，表示 r1 是否等于 0 在这里，setp.eq.u32 指令比较寄存器 $r1 和 0 是否相等，如果相等，p0 被设置为 1（True），否则 p0 被设置为 0（False）。p0 就是一个谓词，用来表示条件是否成立。)Constants In PTX, integer constants may be used as predicates. For predicate-type data initializers and instruction operands, integer constants are interpreted as in C, i.e., zero values are False​ and non-zero values are True​.\n4.5.4 Constant Expressions In PTX, constant expressions are formed using operators as in C and are evaluated using rules similar to those in C, but simplified by restricting types and sizes, removing most casts(类型转换), and defining full semantics(完整的语义) to eliminate cases where expression evaluation in C is implementation dependent.\nConstant expressions are formed from constant literals, unary plus and minus, basic arithmetic operators (addition, subtraction, multiplication, division), comparison operators, the conditional ternary operator ( ?:​ ), and parentheses. Integer constant expressions also allow unary logical negation (!​), bitwise complement (~​), remainder (%​), shift operators (\u0026lt;\u0026lt;​ and \u0026gt;\u0026gt;​), bit-type operators (\u0026amp;​, |​, and ^​), and logical operators (\u0026amp;\u0026amp;​, ||​).\nConstant expressions in PTX do not support casts between integer and floating-point.\nConstant expressions are evaluated using the same operator precedence(运算符优先级) as in C. Table 4 gives operator precedence and associativity. Operator precedence is highest for unary operators(一元运算符是最高的优先级) and decreases with each line in the chart. Operators on the same line have the same precedence and are evaluated right-to-left for unary operators and left-to-right for binary operators.(对于一元运算符求值顺序是从右到左 对于二元运算符求值顺序是从左到右)\n​​\n4.5.5 Integer Constant Expression Evaluation Integer constant expressions are evaluated at compile time according to a set of rules that determine the type (signed .s64​ versus unsigned .u64​) of each sub-expression. These rules are based on the rules in C, but they’ve been simplified to apply only to 64-bit integers, and behavior is fully defined in all cases (specifically, for remainder and shift operators).\nLiterals are signed unless unsigned is needed to prevent overflow, or unless the literal uses a U​ suffix. For example:\n​42​, 0x1234​, 0123​ are signed. ​0xfabc123400000000​, 42U​, 0x1234U​ are unsigned. Unary plus and minus preserve the type of the input operand. For example:\n​+123​, -1​, -(-42)​ are signed. ​-1U​, -0xfabc123400000000​ are unsigned. Unary logical negation (!​) produces a signed result with value 0​ or 1​.\nUnary bitwise complement (~​) interprets the source operand as unsigned and produces an unsigned result.\nSome binary operators require normalization of source operands. This normalization is known as the usual arithmetic conversions and simply converts both operands to unsigned type if either operand is unsigned.\nAddition, subtraction, multiplication, and division perform the usual arithmetic conversions and produce a result with the same type as the converted operands. That is, the operands and result are unsigned if either source operand is unsigned, and is otherwise signed.\nRemainder (%​) interprets the operands as unsigned. Note that this differs from C, which allows a negative divisor but defines the behavior to be implementation dependent.\nLeft and right shift interpret the second operand as unsigned and produce a result with the same type as the first operand. Note that the behavior of right-shift is determined by the type of the first operand: right shift of a signed value is arithmetic and preserves the sign, and right shift of an unsigned value is logical and shifts in a zero bit.\nAND (\u0026amp;​), OR (|​), and XOR (^​) perform the usual arithmetic conversions and produce a result with the same type as the converted operands.\nAND_OP (\u0026amp;\u0026amp;​), OR_OP (||​), Equal (==​), and Not_Equal (!=​) produce a signed result. The result value is 0 or 1.\nOrdered comparisons (\u0026lt;​, \u0026lt;=​, \u0026gt;​, \u0026gt;=​) perform the usual arithmetic conversions on source operands and produce a signed result. The result value is 0​ or 1​.\nCasting of expressions to signed or unsigned is supported using (.s64​) and (.u64​) casts.\nFor the conditional operator ( ? :​ ) , the first operand must be an integer, and the second and third operands are either both integers or both floating-point. The usual arithmetic conversions are performed on the second and third operands, and the result type is the same as the converted type.\n4.5.6 Summary of Constant Expression Evaluation Rules Table 5 contains a summary (焯，有这个总结不早说，前面白看那么久)of the constant expression evaluation rules.\n​​\n‍\n5. PTX State Spaces，Types，and Variables While the specific resources available in a given target GPU will vary, the kinds of resources will be common across platforms, and these resources are abstracted in PTX through ​**state spaces**​ and ​**data types(PTX中通过状态空间和数据类型来抽象资源)**​.(PTX中通过状态空间和数据类型来抽象资源)\n5.1 State Spaces A state space is a storage area with particular characteristics. All variables reside in some state space(所有的变量都驻留在某一个状态空间里面). The characteristics of a state space include its size, addressability, access speed, access rights, and level of sharing between threads.(state space（状态空间）的特性)\nThe state spaces defined in PTX are a byproduct of parallel programming and graphics programming. The list of state spaces is shown in Table 6,and properties of state spaces are shown in Table 7.\n​​\n​​\n5.1.1 Register State Space Registers (.reg​ state space) are fast storage locations. The number of registers is limited, and will vary from platform to platform. When the limit is exceeded, register variables will be spilled to memory, causing changes in performance. For each architecture, there is a recommended maximum number of registers to use (see the CUDA Programming Guide for details).\nRegisters may be typed (signed integer, unsigned integer, floating point, predicate) or untyped. Register size is restricted; aside from predicate registers which are 1-bit, scalar registers have a width of 8-, 16-, 32-, 64-, or 128-bits, and vector registers have a width of 16-, 32-, 64-, or 128-bits. The most common use of 8-bit registers is with ld​, st​, and cvt​ instructions, or as elements of vector tuples.\nRegisters differ from the other state spaces in that they are not fully addressable(寄存器状态空间和其他状态空间的不同之处在于它们不可完全寻址), i.e., it is not possible to refer to the address of a register(不能引用寄存器的地址). When compiling to use the Application Binary Interface (ABI), register variables are restricted to function scope and may not be declared at module scope(寄存器变量被限制到函数范围中，不能在模块范围中引用). When compiling legacy PTX code (ISA versions prior to 3.0) containing module-scoped .reg​ variables, the compiler silently disables use of the ABI. Registers may have alignment boundaries(边界对齐) required by multi-word loads and stores.\n5.1.2 Special Register State Space(存了一些预定义的特定平台的寄存器，如网格、集群、CTA和线程参数、时钟计数器以及性能监控寄存器。所有特殊寄存器都是预定义的) The special register (.sreg​) state space holds predefined, platform-specific registers, such as grid, cluster, CTA, and thread parameters, clock counters, and performance monitoring registers. All special registers are predefined.\n5.1.3 Constant State Space The constant (​.const​) state space is a read-only memory initialized by the host(常量内促是由主机初始化的常量内存，居然是主机初始化的). Constant memory is accessed with a ld.const​ instruction. Constant memory is restricted in size, currently limited to 64 KB(常量内存的大小限制，有64KB固定的) which can be used to hold statically-sized constant variables. There is an additional 640 KB of constant memory, organized as ten independent 64 KB regions(还有额外的640KB常量内存，被组织成了10个独立的64KB区域). The driver may allocate and initialize constant buffers in these regions and pass pointers to the buffers as kernel function parameters(由驱动来分配和初始化这些区域中的常量内存，并将指向这些缓存的指针作为kernel的参数传递). Since the ten regions are not contiguous, the driver must ensure that constant buffers are allocated so that each buffer fits entirely within a 64 KB region and does not span a region boundary.(由于这十个区域不连续，驱动必须确保常量缓冲的分配方式，使每个缓冲区完全适合在一个64KB区域内，并且不跨越区域边界)\nStatically-sized constant variables have an optional variable initializer; constant variables with no explicit initializer are initialized to zero by default(没有显式初始化器的常量变量默认为初始化为零). Constant buffers allocated by the driver are initialized by the host, and pointers to such buffers are passed to the kernel as parameters. See the description of kernel parameter attributes in Kernel Function Parameter Attributes for more details on passing pointers to constant buffers as kernel parameters.\n5.1.3.1 Banked Constant State Space（deprecated） Previous versions of PTX exposed constant memory as a set of eleven 64 KB banks, with explicit bank numbers required for variable declaration and during access.\nPrior to PTX ISA version 2.2, the constant memory was organized into fixed size banks. There were eleven 64 KB banks, and banks were specified using the .const[bank]​ modifier, where bank ranged from 0 to 10. If no bank number was given, bank zero was assumed.\nBy convention, bank zero was used for all statically-sized constant variables. The remaining banks were used to declare incomplete constant arrays (as in C, for example), where the size is not known at compile time. For example, the declaration\n1 .extern .const[2] .b32 const_buffer[]; resulted in const_buffer​ pointing to the start of constant bank two. This pointer could then be used to access the entire 64 KB constant bank. Multiple incomplete array variables declared in the same bank were aliased, with each pointing to the start address of the specified constant bank.\nTo access data in contant banks 1 through 10, the bank number was required in the state space of the load instruction. For example, an incomplete array in bank 2 was accessed as follows:\n1 2 .extern .const[2] .b32 const_buffer[]; ld.const[2].b32 %r1, [const_buffer+4]; // load second word In PTX ISA version 2.2, we eliminated explicit banks and replaced the incomplete array representation of driver-allocated constant buffers with kernel parameter attributes that allow pointers to constant buffers to be passed as kernel parameters.\n‍\n5.1.4 Global State Space The global (​.global​) state space is memory that is accessible by all threads in a context.(global state space是一块所有线程都可以访问的内存) It is the mechanism by which threads in different CTAs, clusters, and grids can communicate(是一种不同CTAs，不同clusters，不同grids都可以交流的机制). Use ld.global​, st.global​, and atom.global​ to access global variables.\nGlobal variables have an optional variable initializer; global variables with no explicit initializer are initialized to zero by default.(典中典之默认初始化为零)\n5.1.5 Local State Space The local state space (.local​) is private memory for each thread to keep its own data. It is typically standard memory with cache(local state space是带有缓存的标准内存). The size is limited, as it must be allocated on a per-thread basis(必须按照每个线程分配). Use ld.local​ and st.local​ to access local variables.\nWhen compiling to use the Application Binary Interface (ABI) , .local​ state-space variables must be declared within function scope and are allocated on the stack(local state space必须分配到函数范围，并且必须在栈上分配内存). In implementations that do not support a stack, all local memory variables are stored at fixed addresses, recursive function calls are not supported, and ​.local​ variables may be declared at module scope(在不支持栈的实现中，所有的局部内存变量存储在固定地址中，不支持递归函数调用，并且local变量可以在模块范围内声明). When compiling legacy PTX code (ISA versions prior to 3.0) containing module-scoped .local​ variables, the compiler silently disables use of the ABI.\n5.1.6 Parameter State Space The parameter (.param​) state space is used (1) to pass input arguments from the host to the kernel, (2a) to declare formal input and return parameters for device functions called from within kernel execution, and (2b) to declare locally-scoped byte array variables that serve as function call arguments, typically for passing large structures by value to a function. Kernel function parameters differ from device function parameters in terms of access and sharing (read-only versus read-write, per-kernel versus per-thread)(parameter对于kernel function（global）和device function（device）的访问类型和作用域是不一样的). Note that PTX ISA versions 1.x supports only kernel function parameters in .param space(ptx 1.x版本只支持function parameters in .param space（不支持device function）); device function parameters were previously restricted to the register state space. The use of parameter state space for device function parameters was introduced in PTX ISA version 2.0(parameter for device function 在PTX 2.x引入) and requires target architecture sm_20​ or higher. Additional sub-qualifiers ​::entry​ or ​::func​ can be specified on instructions with ​.param​ state space to indicate whether the address refers to kernel function parameter or device function parameter(可以在.param后面指定额外的子限定符::entry或::func，来指示地址是否引用内核函数或设备函数参数). If no sub-qualifier is specified with the .param​ state space, then the default sub-qualifier is specific to and dependent on the exact instruction. For example, st.param​ is equivalent to st.param::func​ whereas isspacep.param​ is equivalent to isspacep.param::entry​. Refer to the instruction description for more details on default sub-qualifier assumption.\nNote(讲了一大堆，重心落在第一句和最后一句，说的是： “由于.param空间的位置是implementation specific，所以PTX code should no assumptions about the relative locations or ordering of .param space variables.”)\nThe location of parameter space is implementation specific. For example, in some implementations kernel parameters reside in global memory. No access protection is provided between parameter and global space in this case. Though the exact location of the kernel parameter space is implementation specific, the kernel parameter space window is always contained within the global space window. Similarly, function parameters are mapped to parameter passing registers and/or stack locations based on the function calling conventions of the Application Binary Interface (ABI) . Therefore, PTX code should make no assumptions about the relative locations or ordering of .param​ space variables.\n5.1.6.1 Kernel Function Parameters Each kernel function definition includes an optional list of parameters. These parameters are addressable, read-only variables declared in the .param​ state space. Values passed from the host to the kernel(值从host到kernel，用ld.param ) are accessed through these parameter variables using ld.param​ instructions. The kernel parameter variables are shared across all CTAs from all clusters within a grid.(这么大范围的共享，我猜是global)\nThe address of a kernel parameter may be moved into a register using the ​mov​ instruction. The resulting address is in the ​.param​ state space and is accessed using ​ld.param(内核参数的地址可以用mov来移入寄存器，拿到的这个地址在.param状态空间中，可以通过ld.param来访问)​ instructions.(内核参数的地址可以用mov来移入寄存器，拿到的这个地址在.param状态空间中，可以通过ld.param来访问)\nExample(对于这个示例， .entry是一个directive，他用于表明此处是一个内核入口点 foo是函数名 .param是space state .b32表明参数是32位的（bit？binary？） .align是一个directive，属于Variables，后面跟一个可选的byte-count来指定对齐方式 到正文 .reg .u32 %n; .reg .f64 %d; 意为声明一个32位无符号整数寄存器，取名叫做n，用%n引用 声明一个64位浮点数寄存器，取名叫做d，用%d引用 然后是 ld.param.u32 %n, [N]; ld.param.f64 %d, [buffer]; ld是一个instruction，（ld move data from addressable state space to registers.） 表示从param state space中分别ld一个u32和f64的数据)\n1 2 3 4 5 6 7 8 .entry foo ( .param .b32 N, .param .align 8 .b8 buffer[64] ) { .reg .u32 %n; .reg .f64 %d; ld.param.u32 %n, [N]; ld.param.f64 %d, [buffer]; ... Example(和前一个例子差不多 .entry表明函数入口 bar是函数名称 有一个b32的参数叫做len .reg .u32 %ptr,%n;声明了两个u32的寄存器分别叫做ptr和n mov（The mov instructions copies data between registers）mov指令在registers之间复制数据，但实际上这里是从state space到register，应该都可以吧 mov.u32 %ptr, len;将len的值复制到ptr寄存器中去 ld.param.u32 %n, [%ptr];就是从ptr加载一个u32到n中去)\n1 2 3 4 5 6 7 .entry bar ( .param .b32 len ) { .reg .u32 %ptr, %n; mov.u32 %ptr, len; ld.param.u32 %n, [%ptr]; ... Kernel function parameters (parameters既可以保留数据值也可以存const、global、local or shared state space地址)may represent normal data values, or they may hold addresses to objects in constant, global, local, or shared state spaces. In the case of pointers, the compiler and runtime system need information about which parameters are pointers, and to which state space they point(如果parameters是指针的话，那么编译器和运行时系统就需要关于哪些参数是指针，并且这些指针指向哪些state space的信息。 存在提供这些信息的directive，具体的内容在Kernel Function Parameter Attributes里面看). Kernel parameter attribute directives are used to provide this information at the PTX level. See Kernel Function Parameter Attributes for a description of kernel parameter attribute directives.\nNote(出现了一个新的instructino，cvta，预告一下，这个instruction在9.7.9.20)\nThe current implementation does not allow creation of generic pointers to constant variables (cvta.const​) in programs that have pointers to constant buffers passed as kernel parameters.\n5.1.6.2 Kernel Function Parameter Attributes(可以用.ptr来表明该参数是指向内存的指针，还可以指示该指针所指向内存的状态空间和对齐方式) Kernel function parameters may be declared with an optional .ptr attribute to indicate that a parameter is a pointer to memory, and also indicate the state space and alignment of the memory being pointed to. Kernel Parameter Attribute: .ptr describes the .ptr​ kernel parameter attribute.\n5.1.6.3 Kernel Parameter Attribute：.ptr .ptr\nKernel parameter alignment attribute.\nSyntax(这里的.type就是u32之类的，这里的.space就是state space)\n1 2 3 4 .param .type .ptr .space .align N varname .param .type .ptr .align N varname .space = { .const, .global, .local, .shared }; Description\nUsed to specify the state space and, optionally, the alignment(alignment是可选的) of memory pointed to by a pointer type kernel parameter. The alignment value N, if present, must be a power of two. If no state space is specified, the pointer is assumed to be a generic address pointing to one of const, global, local, or shared memory(如果没有指向state space，那么这个指针就被假定为指向const、global、local or shared memory的通用地址). If no alignment is specified, the memory pointed to is assumed to be aligned to a 4 byte boundary.(如果没有指定alignment，那么就默认对齐4byte)\nSpaces between ​.ptr​, ​.space​, and ​.align​ may be eliminated to improve readability.(这之间的空格也可以消除)​\nPTX ISA Notes\nIntroduced in PTX ISA version 2.2. Support for generic addressing of .const space added in PTX ISA version 3.1. Target ISA Notes\nSupported on all target architectures. Examples(这个例子很清晰，是按照前面说的语法来的 )\n1 2 3 4 5 6 .entry foo ( .param .u32 param1, .param .u32 .ptr.global.align 16 param2, .param .u32 .ptr.const.align 8 param3, .param .u32 .ptr.align 16 param4 // generic address // pointer ) { .. } 5.1.6.4 Device Function Parameters PTX ISA version 2.0 extended the use of parameter space to device function parameters(这一段有点复杂，总之就是在PTX ISA2中扩展了parameter空间对设备函数参数的使用). The most common use is for passing objects by value that do not fit within a PTX register, such as C structures larger than 8 bytes. In this case, a byte array in parameter space is used. Typically, the caller will declare a locally-scoped .param​ byte array variable that represents a flattened C structure or union. This will be passed by value to a callee, which declares a .param​ formal parameter having the same size and alignment as the passed argument.\nExample(有一点意外，这里参数.param .align 8 .b8 buffer[12]里面的 .8的意思是buffer[12]里面的数据是字节，即buffer是一个字节数组，如果将这里的.b8改成f64，则表明这个buffer是一个double数组，说明前面的理解是不到位的。 这一个示例对.type这样的ptx的说明很清晰 第一段是函数实现，这个函数的具体的内容 第二段是函数的调用：call foo,（4，mystruct）; 看第二段有一个包括了double和int的结构体，加在一起8+4=12字节，超过了8字节，如上述所说的使用，就需要用param空间了 前面遇到过ld，顺便看了一下st，st的意思是from register to memory 由于mystruct是由一个double和一个int组成的， 所以他这里是先将8字节大小的f64 dbl放入mystruct里面 然后偏移8字节再放入4字节大小的s32 x，在传入foo调用)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // pass object of type struct { double d; int y; }; .func foo ( .reg .b32 N, .param .align 8 .b8 buffer[12] ) { .reg .f64 %d; .reg .s32 %y; ld.param.f64 %d, [buffer]; ld.param.s32 %y, [buffer+8]; ... } // code snippet from the caller // struct { double d; int y; } mystruct; is flattened, passed to foo ... .reg .f64 dbl; .reg .s32 x; .param .align 8 .b8 mystruct; ... st.param.f64 [mystruct+0], dbl; st.param.s32 [mystruct+8], x; call foo, (4, mystruct); ... See the section on function call syntax for more details.\nFunction input parameters may be read via ld.param​ and function return parameters may be written using st.param​; it is illegal to write to an input parameter or read from a return parameter.(没有具体示例，不是很懂这个非法场景)\nAside from passing structures by value, .param​ space is also required whenever a formal parameter has its address taken within the called function. In PTX, the address of a function input parameter may be moved into a register using the mov​ instruction. Note that the parameter will be copied to the stack if necessary, and so the address will be in the .local​ state space and is accessed via ld.local​ and st.local​ instructions. It is not possible to use mov​ to get the address of or a locally-scoped .param​ space variable. Starting PTX ISA version 6.0, it is possible to use mov​ instruction to get address of return parameter of device function.\nExample(出现了一个新的instruction，在9.7.12.2里面被称为control flow instructions包括：{}、@、bra、call、ret、exit 应该就是跳转（branch）的意思 出现了一个新的type specifier（9.3），.pred，长的很像instruction，但是没在instruction列表里面找到他，作用应该只是用于表明此变量是谓词变量（比大小？布尔类型？） 出现了一个新的instruction，在9.7.6里面被称为comparison and selection instructions包括set、setp、selp、slct 他妈的看上去set和setp是一样的，damn 这里的eq是comparison operators在9.3.1comparison里面有描述 值得一提的是这个loop没有文档的描述（显然猜测为普通的循环） 这个例子中第一次出现了在声明寄存器变量的时候用.pred表明这个变量是谓词类型（据AI说这是bool类型） @%p bra Done;这里的整个循环是如果%p为true则跳转到Done，即结束循环 这之前有一句setp.eq.u32 %p, %n, 0;会一直做n和0的判断，如果n等于0，则将p设置为true，即若n为0，则跳出循环，去Done 循环体里面有一个sub指令，表明每次循环n都会自减一次，所以这个循环还是很完整合理的。)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // pass array of up to eight floating-point values in buffer .func foo ( .param .b32 N, .param .b32 buffer[32] ) { .reg .u32 %n, %r; .reg .f32 %f; .reg .pred %p; ld.param.u32 %n, [N]; mov.u32 %r, buffer; // forces buffer to .local state space Loop: setp.eq.u32 %p, %n, 0; @%p bra Done; ld.local.f32 %f, [%r]; ... add.u32 %r, %r, 4; sub.u32 %n, %n, 1; bra Loop; Done: ... } 5.1.7 Shared State Space The shared (.shared​) state space is a memory that is owned by an executing CTA and is accessible to the threads of all the CTAs within a cluster(shared state space居然是accessible to the threads of all the CTAs within a cluster，但是我猜是只有CTA内部才能通信，虽然整个clusters可以访问). An address in shared memory can be read and written by any thread in a CTA cluster.\nAdditional sub-qualifiers(他这里表明在.shared 之后可以指定::cta或者::cluster来表明这个shared地址是属于正执行的CTA还是cluster中任何CTA的共享内存窗口。.shared::cta 窗口中的地址也包含在 .shared::cluster窗口中。如果没有指定则默认是::cta，例如：ld.shared 相当于 ld.shared::cta) ::cta​ or ::cluster​ can be specified on instructions with .shared​ state space to indicate whether the address belongs to the shared memory window of the executing CTA or of any CTA in the cluster respectively. The addresses in the .shared::cta​ window also fall within the .shared::cluster​ window. If no sub-qualifier is specified with the .shared​ state space, then it defaults to ::cta​. For example, ld.shared​ is equivalent to ld.shared::cta​.\nVariables declared in ​.shared​ state space refer to the memory addresses in the current CTA. Instruction ​mapa​ gives the ​.shared::cluster(.shared指向当前CTA中的内存地址，mapa给出了在同一cluster里面其他CTA的地址)​ address of the corresponding variable in another CTA in the cluster.(.shared指向当前CTA中的内存地址，mapa给出了在同一cluster里面其他CTA的地址)\nShared memory typically has some optimizations to support the sharing. One example is broadcast(shared的优化方案例子——————广播); where all threads read from the same address. Another is sequential access from sequential threads.\n5.1.8 Texture State Space（deprecated） The texture (.tex​) state space is global memory accessed via the texture instruction. It is shared by all threads in a context. Texture memory is read-only and cached, so accesses to texture memory are not coherent with global memory stores to the texture image.\nThe GPU hardware has a fixed number of texture bindings that can be accessed within a single kernel (typically 128). The .tex directive will bind the named texture memory variable to a hardware texture identifier, where texture identifiers are allocated sequentially beginning with zero. Multiple names may be bound to the same physical texture identifier. An error is generated if the maximum number of physical resources is exceeded. The texture name must be of type .u32​ or .u64​.\nPhysical texture resources are allocated on a per-kernel granularity, and .tex​ variables are required to be defined in the global scope.\nTexture memory is read-only. A texture’s base address is assumed to be aligned to a 16 byte boundary.\nExample\n1 2 3 4 .tex .u32 tex_a; // bound to physical texture 0 .tex .u32 tex_c, tex_d; // both bound to physical texture 1 .tex .u32 tex_d; // bound to physical texture 2 .tex .u32 tex_f; // bound to physical texture 3 Note\nExplicit declarations of variables in the texture state space is deprecated, and programs should instead reference texture memory through variables of type .texref​. The .tex​ directive is retained for backward compatibility, and variables declared in the .tex​ state space are equivalent to module-scoped .texref​ variables in the .global​ state space.\nFor example, a legacy PTX definitions such as\n1 .tex .u32 tex_a; is equivalent to:\n1 .global .texref tex_a; See Texture Sampler and Surface Types for the description of the .texref​ type and Texture Instructions for its use in texture instructions.\n5.2. Tpyes 5.2.1 Fundamental Types In PTX, the fundamental types reflect the native data types supported by the target architectures. A fundamental type specifies both a basic type and a size(一个type由basic type和size组成). Register variables are always of a fundamental type, and instructions operate on these types. The same type-size specifiers are used for both variable definitions and for typing instructions, so their names are intentionally short.(这里说了type specifiers到处都在用，所以设计的很短)\nTable 8 lists the fundamental type specifiers for each basic type:\n​​\nMost instructions have one or more type specifiers, needed to fully specify instruction behavior. Operand types and sizes are checked against instruction types for compatibility.\nTwo fundamental types are compatible if they have the same basic type and are the same size. Signed and unsigned integer types are compatible if they have the same size. The bit-size type is compatible with any fundamental type having the same size.\nIn principle, all variables (aside from predicates) could be declared using only bit-size types(所有的变量（除了谓词以外）都可以仅使用位大小类型来声明), but typed variables enhance program readability and allow for better operand type checking.\n5.2.2 Restricted Use of Sub-Word Sizes The ​.u8​, ​.s8​, and ​.b8​ instruction types are restricted to ​ld​, ​st​, and ​cvt​ instructions(u8、s8和b8仅限于ld、st和cvt使用). The .f16​ floating-point type is allowed only in conversions to and from .f32​, .f64​ types, in half precision floating point instructions and texture fetch instructions. The .f16x2​ floating point type is allowed only in half precision floating point arithmetic instructions and texture fetch instructions.\nFor convenience(为了方便，ld、st和cvt允许源和目的操作数比指令本身要求的类型大小要大), ld​, st​, and cvt​ instructions permit source and destination data operands to be wider than the instruction-type size, so that narrow values may be loaded, stored, and converted using regular-width registers. For example, 8-bit or 16-bit values may be held directly in 32-bit or 64-bit registers when being loaded, stored, or converted to other types and sizes.\n5.2.3 Alternate Floating-Point Data Formats The fundamental floating-point types supported in PTX have implicit bit representations(PTX支持的基本浮点类型具有隐式的位表示，指示用于存储指数和尾数的位数。例如f16隐式为e5m10) that indicate the number of bits used to store exponent and mantissa. For example, the .f16​ type indicates 5 bits reserved for exponent and 10 bits reserved for mantissa. In addition to the floating-point representations assumed by the fundamental types, PTX allows the following alternate floating-point data formats:\n​bf16(8e7m)​ data format:This data format is a 16-bit floating point format with 8 bits for exponent and 7 bits for mantissa. A register variable containing ​bf16​ data must be declared with ​.b16(包含bf16数据的寄存器变量必须使用.b16类型声明)​ type.(包含bf16数据的寄存器变量必须使用.b16类型声明)\n​e4m3​ data format:This data format is an 8-bit floating point format with 4 bits for exponent and 3 bits for mantissa. The ​e4m3​ encoding does not support infinity and ​NaN​ values are limited to ​0x7f​ and ​0xff​. A register variable containing ​e4m3(e4m3不支持无限大，如果使用e4m3则0x7f和0xff就会导致NaN 包含e4m3的寄存器变量必须用位大小类型声明)​ value must be declared using bit-size type.(e4m3不支持无限大，如果使用e4m3则0x7f和0xff就会导致NaN 包含e4m3的寄存器变量必须用位大小类型声明)\n​e5m2​ data format:This data format is an 8-bit floating point format with 5 bits for exponent and 2 bits for mantissa. A register variable containing ​e5m2(同样的，包含e5m2的寄存器必须用位大小类型声明)​ value must be declared using bit-size type.(同样的，包含e5m2的寄存器必须用位大小类型声明)\n​tf32​ data format:This data format is a special 32-bit floating point format supported by the matrix multiply-and-accumulate instructions, with the same range as .f32​ and reduced precision (\u0026gt;=10 bits). The internal layout of tf32​ format is implementation defined. PTX facilitates conversion from single precision ​.f32​ type to ​tf32​ format. A register variable containing ​tf32​ data must be declared with ​.b32(ptx支持从单精度f32到tf32的转换，包含tf32的寄存器变量必须使用b32类型声明)​ type.(ptx支持从单精度f32到tf32的转换，包含tf32的寄存器变量必须使用b32类型声明)\n​e2m1​ data format:This data format is a 4-bit floating point format with 2 bits for exponent and 1 bit for mantissa. The ​e2m1​ encoding does not support infinity and ​NaN(e2m1也不支持无限大)​. e2m1​ values must be used in a packed format specified as ​e2m1x2​. A register variable containing two ​e2m1​ values must be declared with ​.b8(e2m1必须以指定的压缩格式e2m1x2使用，包含两个e2m1值的寄存器变量必须使用.b8类型声明)​ type.(e2m1必须以指定的压缩格式e2m1x2使用，包含两个e2m1值的寄存器变量必须使用.b8类型声明)\n​e2m3​ data format:This data format is a 6-bit floating point format with 2 bits for exponent and 3 bits for mantissa. The ​e2m3​ encoding does not support infinity and ​NaN(e2m3不支持无限大和NaN)​. e2m3(e2m3必须用packed格式e2m3x2使用)​ values must be used in a packed format specified as (e2m3必须以指定的packed格式e2m3x2使用)​e2m3x2(e2m3必须用packed格式e2m3x2使用)​. A register variable containing two e2m3​ values must be declared with ​.b16​ type(e2m3必须声明为.b16类型，) where each .b8​ element has 6-bit floating point value and 2 MSB bits padded with zeros.\n​e3m2​ data format:This data format is a 6-bit floating point format with 3 bits for exponent and 2 bits for mantissa. The ​e3m2​ encoding does not support infinity and ​NaN(e3m2不支持无限大和NaN). e3m2​ values must be used in a packed format specified as ​e3m2x2(e3m2必须以指定的打包格式e3m2x2使用)​. A register variable containing two e3m2​ values must be declared with ​.b16​ type (包含两个e3m2值的寄存器变量必须声明为.b16类型，其中每个.b8元素具有6为浮点数，并且高两位用0填充)where each .b8​ element has 6-bit floating point value and 2 MSB bits padded with zeros.\n​ue8m0​ data format:This data format is an 8-bit unsigned floating-point format with 8 bits for exponent and 0 bits for mantissa. The ue8m0​ encoding does not support infinity.(不支持无限大) NaN​ value is limited to ​0xff(NaN被限制为0xff)​. ue8m0​ values must be used in a packed format specified as ​ue8m0x2(ue8m0值必须以指定的打包格式ue8m0x2使用。包含连个ue8m0 的寄存器必须声明为.b16类型)​. A register variable containing two ue8m0​ values must be declared with .b16​ type.\n​ue4m3​ data format:This data format is a 7-bit unsigned floating-point format with 4 bits for exponent and 3 bits for mantissa. The ue4m3​ encoding does not support infinity(同样的不支持无限大). NaN​ value is limited to ​0x7f(NaN被限制为0x7f)​. A register variable containing single ue4m3​ value must be declared with .b8​ type having MSB bit padded with zero.\nAlternate data formats cannot be used as fundamental types. They are supported as source or destination formats by certain instructions.(替代数据不能作为基本类型使用。它们仅在某些指令中作为源格式或目标格式支持)\n​​\n5.2.4 Packed Data Types Certain PTX instructions operate on two or more sets of inputs in parallel, and produce two or more outputs(某些PTX指令并行处理两个或多个输入集，并生成两个或多个输出。此类指令可以使用以打包格式存储的数据。). Such instructions can use the data stored in a packed format. PTX supports packing two or four values of the same scalar data type into a single, larger value(PTX支持将两个或四个相同标量数据类型的值打包成一个单一的、更大的值。). The packed value is considered as a value of a packed data type. In this section we describe the packed data types supported in PTX.\n5.2.4.1 Packed Floating Point Data Types PTX supports various variants of packed floating point data types(PTX支持许多packed 浮点数据类型，如下table9所示). Out of them, only ​.f16x2​ is supported as a fundamental type(只有.f16x2被支持为基本类型), while others cannot be used as fundamental types - they are supported as instruction types on certain instructions(不能作为基本类型的packed data types只能在某些指令中作为指令类型得到支持。). When using an instruction with such non-fundamental types, the operand data variables must be of bit type of appropriate size. For example, all of the operand variables must be of type .b32​ for an instruction with instruction type as .bf16x2​. Table 9 described various variants of packed floating point data types in PTX.\n​​\n5.2.4.2 Packed Integer Data Types PTX supports two variants of packed integer data types: ​.u16x2​ and ​.s16x2(和浮点数不同，PTX只支持两种packed 整数数据类型：.u16x2和.s16x2)​. The packed data type consists of two .u16​ or .s16​ values. A register variable containing ​.u16x2​ or ​.s16x2​ data must be declared with ​.b32​ type(包含 .u16x2 或 .s16x2 数据的寄存器变量必须声明为 .b32 类型。打包整数数据类型不能作为基本类型使用。它们仅在某些指令中作为指令类型得到支持。). Packed integer data types cannot be used as fundamental types. They are supported as instruction types on certain instructions.\n5.3. Texture Sampler and Surface Types(似乎与数值计算这个方向没有太大的关系，暂且没看，但是为了保持PTX学习的完整性，还是CV了上去) PTX includes built-in ​opaque​ types(PTX有内置的不透明类型，用于定义纹理、采集器和表面描述符变量。) for defining texture, sampler, and surface descriptor variables. These types have named fields similar to structures, but all information about layout, field ordering, base address, and overall size is hidden to a PTX program, hence the term ​opaque(但是所有不透明类型关于布局、字段顺序、基址和整体大小的信息对于PTX程序都是隐藏的，因此称为不透明类型。). The use of these opaque types is limited to(使用这些不透明类型的范围仅限于):\nVariable definition within global (module) scope and in kernel entry parameter lists. Static initialization of module-scope variables using comma-delimited static assignment expressions for the named members of the type. Referencing textures, samplers, or surfaces via texture and surface load/store instructions (tex​, suld​, sust​, sured​). Retrieving the value of a named member via query instructions (txq​, suq​). Creating pointers to opaque variables using mov​, e.g., mov.u64 reg, opaque_var;​. The resulting pointer may be stored to and loaded from memory, passed as a parameter to functions, and de-referenced by texture and surface load, store, and query instructions, but the pointer cannot otherwise be treated as an address, i.e., accessing the pointer with ld​ and st​ instructions, or performing pointer arithmetic will result in undefined results. Opaque variables may not appear in initializers, e.g., to initialize a pointer to an opaque variable. 5.3.1 Texture and Surface Properties Fields width​, height​, and depth​ specify the size of the texture or surface in number of elements in each dimension.\nThe channel_data_type​ and channel_order​ fields specify these properties of the texture or surface using enumeration types corresponding to the source language API. For example, see Channel Data Type and Channel Order Fields for the OpenCL enumeration types currently supported in PTX.\n5.3.2 Sampler Properties The normalized_coords​ field indicates whether the texture or surface uses normalized coordinates in the range [0.0, 1.0) instead of unnormalized coordinates in the range [0, N). If no value is specified, the default is set by the runtime system based on the source language.\nThe filter_mode​ field specifies how the values returned by texture reads are computed based on the input texture coordinates.\nThe addr_mode_{0,1,2}​ fields define the addressing mode in each dimension, which determine how out-of-range coordinates are handled.\nSee the CUDA C++ Programming Guide for more details of these properties.\n​​\nIn independent texture mode, the sampler properties are carried in an independent .samplerref​ variable, and these fields are disabled in the .texref​ variables. One additional sampler property, force_unnormalized_coords​, is available in independent texture mode.\nThe force_unnormalized_coords​ field is a property of .samplerref​ variables that allows the sampler to override the texture header normalized_coords​ property. This field is defined only in independent texture mode. When True​, the texture header setting is overridden and unnormalized coordinates are used; when False​, the texture header setting is used.\nThe force_unnormalized_coords​ property is used in compiling OpenCL; in OpenCL, the property of normalized coordinates is carried in sampler headers. To compile OpenCL to PTX, texture headers are always initialized with normalized_coords​ set to True, and the OpenCL sampler-based normalized_coords​ flag maps (negated) to the PTX-level force_unnormalized_coords​ flag.\nVariables using these types may be declared at module scope or within kernel entry parameter lists. At module scope, these variables must be in the .global​ state space. As kernel parameters, these variables are declared in the .param​ state space.\nExample\n1 2 3 .global .texref my_texture_name; .global .samplerref my_sampler_name; .global .surfref my_surface_name; When declared at module scope, the types may be initialized using a list of static expressions assigning values to the named members.\nExample\n1 2 3 4 .global .texref tex1; .global .samplerref tsamp1 = { addr_mode_0 = clamp_to_border, filter_mode = nearest }; 5.3.3 Channel Data Type and Channel Order Fields The channel_data_type​ and channel_order​ fields have enumeration types corresponding to the source language API. Currently, OpenCL is the only source language that defines these fields. Table 13 and Table 12 show the enumeration values defined in OpenCL version 1.0 for channel data type and channel order.\n​​\n​​\n5.4. Variables In PTX, a variable declaration describes both the variable’s type and its state space(PTX中的一个变量声明同时描述了变量的类型和其状态空间。). In addition to fundamental types, PTX supports types for simple aggregate objects such as vectors and arrays(除了基本类型，PTX还支持用于简单聚合对象的类型，如向量和数组)\n5.4.1 Variable Declarations All storage for data is specified with variable declarations. Every variable must reside in one of the state spaces(每一个变量都必须驻留在一个state space之中) enumerated in the previous section.\nA variable declaration names the space in which the variable resides, its type and size, its name, an optional array size, an optional initializer, and an optional fixed address for the variable(变量声明指定了变量所在的空间、类型和大小、名称（前面这些是必须的） 以下是可选的 可选的数组大小、可选的初始化器以及变量的可选固定地址。).\nPredicate variables may only be declared in the register state space(谓词变量只能在寄存器state space中声明).\nExamples\n1 2 3 4 5 6 .global .u32 loc; .reg .s32 i; .const .f32 bias[] = {-1.0, 1.0}; .global .u8 bg[4] = {0, 0, 0, 0}; .reg .v4 .f32 accel; .reg .pred p, q, r; 5.4.2 Vectors Limited-length vector types are supported. Vectors of length 2 and 4 of any non-predicate fundamental type can be declared by prefixing the type with .v2​ or ​.v4(向量的两种，两个元素或者4个元素)​. Vectors must be based on a fundamental type, and they may reside in the register space. Vectors cannot exceed 128-bits in length; for example, .v4 .f64(.v4.f64的意思是四个f64的意思，那么4个f64的总长度就是4*8=32字节（256位）。而PTX要求向量的长度不能超过128位，即16字节)​ is not allowed. Three-element vectors may be handled by using a ​.v4​ vector(三个元素的向量也要用.v4来处理，其中第四个元素提供填充), where the fourth element provides padding. This is a common case for three-dimensional grids, textures, etc.\nExamples\n1 2 3 .global .v4 .f32 V; // a length-4 vector of floats .shared .v2 .u16 uv; // a length-2 vector of unsigned ints .global .v4 .b8 v; // a length-4 vector of bytes By default, vector variables are aligned to a multiple of their overall size​ (vector length times base-type size)(默认情况下，向量变量按照其整体大小的倍数对齐（向量长度乘以基类型大小）), to enable vector load and store instructions(有一些需要如此对齐的load 和store指令) which require addresses aligned to a multiple of the access size.\n5.4.3 Array Declarations Array declarations are provided to allow the programmer to reserve space(数组声明被程序员用于预留空间). To declare an array, the variable name is followed with dimensional declarations(变量名之后要跟维度声明，和C类似) similar to fixed-size array declarations in C. The size of each dimension is a constant expression.(每个维度的大小都是一个常量表达式)\nExamples\n1 2 .local .u16 kernel[19][19]; .shared .u8 mailbox[128]; The size of the array specifies how many elements should be reserved(数组的大小指定了应预留多少个元素。). For the declaration of array ​kernel​ above, 1919 = 361 halfwords are reserved(在上面的kernel数组声明中，预留了1919=361 half（.u16）), for a total of 722 bytes.\nWhen declared with an initializer, the first dimension of the array may be omitted. The size of the first array dimension is determined by the number of elements in the array initializer.(当数组声明带有初始化器时，可以省略数组的第一个维度。 就像.global .s32 offset[][2] = { {-1, 0}, {0, -1}, {1, 0}, {0, 1} }; 他这里的声明就省略了第一个维度，只给出了第二个维度2. 此时第一个维度的大小由数组初始化器中的元素个数决定)\nExamples\n1 2 .global .u32 index[] = { 0, 1, 2, 3, 4, 5, 6, 7 }; .global .s32 offset[][2] = { {-1, 0}, {0, -1}, {1, 0}, {0, 1} }; Array ​index​ has eight elements, and array ​*offset(这句话只是对上面例子的一个简单的描述)*​ is a 4x2 array.(这句话只是对上面例子的一个简单的描述)\n5.4.4 Initializers Declared variables may specify an initial value using a syntax similar to C/C++, where the variable name is followed by an equals sign and the initial value or values for the variable. A scalar takes a single value, while vectors and arrays take nested lists of values inside of curly braces (the nesting matches the dimensionality of the declaration).\nAs in C, array initializers may be incomplete, i.e., the number of initializer elements may be less than the extent of the corresponding array dimension, with remaining array locations initialized to the default value for the specified array type(和C语言一样，数组初始化器可以是未完成的，即， 初始化元素的数量可能少于相应数组维度的大小 剩余的数组位置将被初始化为指定数组类型的默认值).\nExamples\n1 2 .const .f32 vals[8] = { 0.33, 0.25, 0.125 }; .global .s32 x[3][2] = { {1,2}, {3} }; is equivalent to\n1 2 .const .f32 vals[8] = { 0.33, 0.25, 0.125, 0.0, 0.0, 0.0, 0.0, 0.0 }; .global .s32 x[3][2] = { {1,2}, {3,0}, {0,0} }; Currently, variable initialization is supported only for constant and global state spaces. Variables in constant and global state spaces with no explicit initializer are initialized to zero by default. Initializers are not allowed in external variable declarations.\nVariable names appearing in initializers represent the address of the variable; this can be used to statically initialize a pointer to a variable. Initializers may also contain var+offset expressions, where offset is a byte offset added to the address of var. Only variables in .global​ or .const​ state spaces may be used in initializers. By default, the resulting address is the offset in the variable’s state space (as is the case when taking the address of a variable with a mov​ instruction). An operator, generic()​, is provided to create a generic address for variables used in initializers.\nStarting PTX ISA version 7.1, an operator mask()​ is provided, where mask​ is an integer immediate. The only allowed expressions in the mask()​ operator are integer constant expression and symbol expression representing address of variable. The mask()​ operator extracts n​ consecutive bits from the expression used in initializers and inserts these bits at the lowest position of the initialized variable. The number n​ and the starting position of the bits to be extracted is specified by the integer immediate mask​. PTX ISA version 7.1 only supports extracting a single byte starting at byte boundary from the address of the variable. PTX ISA version 7.3 supports Integer constant expression as an operand in the mask()​ operator.\nSupported values for mask​ are: 0xFF, 0xFF00, 0XFF0000, 0xFF000000, 0xFF00000000, 0xFF0000000000, 0xFF000000000000, 0xFF00000000000000.\n‍\n","date":"2024-12-13T11:48:28+08:00","permalink":"https://cben484.github.io/post/ptx-parallel-thread-execution-ze0wof.html","title":"PTX（Parallel Thread Execution）"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://cben484.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://cben484.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://cben484.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://cben484.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://cben484.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://cben484.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://cben484.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://cben484.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://cben484.github.io/p/emoji-support/","title":"Emoji Support"}]